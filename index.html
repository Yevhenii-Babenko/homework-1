<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Homework#1</title>
</head>
<body>
<style>
    @import url('https://fonts.googleapis.com/css2?family=Roboto:ital,wght@1,300&display=swap');
    td {
        border-bottom: 2px #000 solid;
        width: 900px;
        font-family: 'Roboto', sans-serif;
        font-size: 15px;
    }
    h1, h2, p {
        font-family: 'Roboto', sans-serif;
        margin: 25px;
        padding: 10px 10px;
    }
    .commands {
        width: 250px

    }
    span {
        font-weight: bold;
    }
</style>
<h1>Домашнє завдання: Git </h1>
<table>
    <tr>
        <td class="commands">git congig --global user.name</td>
        <td>Ця команда використовується для щоб задати ім'я користувача при першому налаштуванні Git під користувача.</td>
    </tr>
    <tr>
        <td class="commands">git config --global user.email</td>
        <td>Ця команда використовується для щоб задати електронну скриньку користувача при першому налаштуванні Git.</td>
    </tr>
    <tr>
        <td class="commands"> git init </td>
        <td>Використовується для створення нового репозиторія. Коли Ви написали "git init", Git "включається" чи "запускається" для даного репозиторію (тобто папки). Після запуску git init програма git одержує право на доступ до цієї папки і створить прихований каталог .git, де буде зберігатися історія репозиторія і його конфігурації, службові документи,а якщо видалити цей католог, то Git вже не буде "бачити" цю папку (тобто якщо ми напишемо "git status", нам дадуть відповідь що це "не Git репозиторій").</td>
    </tr>
    <tr>
        <td class="commands">git status</td>
        <td> Ця команда повертає інформацію про поточний стан репозиторія: що нового, що змінилося, які файли змінені, але не додано в індекс; які очікують коммітов в індексі. Додатково до цього виводяться підказки про те, як змінити стан файлів.
        </td>
    </tr>
    <tr>
        <td class="commands">git add</td>
        <td>Ця команда додає вміст робочої директорії в індекс (staging area) для подальшого комміта. Тобто описуючи простими словами: "хочеш додати файли - тисни цю команду використовуючи відповідні позначки для додавання всіх файлів дерикторії або одного файлу, прописавши його ім'я із розширенням. Ця команда викоористовується зазвичай із "." або "*" для тобо щоб додати всі файли.</td>
    </tr>
    <tr>
        <td class="commands">git commit</td>
        <td>Команда git commit бере всі дані, додані в індекс (Індекс (Index) або область підготовлених файлів (Staging Area), містить інформацію про те, що повинно увійти в наступний Комміт) за допомогою git add, і зберігає їх зліпок у внутрішній базі даних.
            Є два варіанти вводу git commit із та без аргументу "m". При введенні git commit без введення "m" програма відкриє обраний вами текстовий редактор, де потрібно описати зміни або що додано у Комміт. При уведенні команди git commit -m"name of changes" ми відразу описуємо що змінили чи додали - даний варіант являється швидшим.</td>
    </tr>
    <tr>
        <td class="commands">git log</td>
        <td>Команда git log використовується для перегляду історії коммітов в хронологічному порядку починаючи з останнього та йдучи до витоків проекту. За замовчуванням, вона показує лише історію поточної гілки, але може бути налаштована на висновок історії інших, навіть декількох відразу, гілок. Також її можна використовувати для перегляду відмінностей між гілками на рівні коммітов.
            Команда git log має дуже велику кількість опцій для пошуку коммітов за різними критеріями.
            Аргумент -p або --patch, який показує різницю (виводить патч), внесену в кожен комітт. Можливо обмежити кількість записів у висновку команди; використовуйте параметр -2 для виведення тільки двох записів;
            Опція --stat надає можливість побачити скорочену статистику для кожного коммітов;
            Опція  --pretty змінює формат виведення. Існує кілька вбудованих варіантів відображення. Опція oneline виводить кожен Комміт в один рядок, що може бути дуже зручним якщо ви переглядаєте велику кількість коммітов. До того ж, опції short, full і fuller роблять висновок приблизно в тому ж форматі, але з меншою або більшою кількістю інформації відповідно;
            git log --pretty = format відображає найбільш корисні опції для зміни формату.</td>
    </tr>
    <tr>
        <td class="commands">git checkout</td>
        <td>Ця команда може бути використана для створення гілок або перемикання між ними. Наприклад git checkout -b BRANCH_NAME створить нову гілку і відразу ж переключиться на неї. Для того щоб просто переключитися між гілками необхідно написати git checkout BRANCH_NAME. Дана команда входить до теми розгалудження та злиття гілок в git. Існує схожа, в плані розгалудження, команда git branch BRANCH_NAME, її відмінність полягає в тому, що створює нову гілку, але залишає вас на тій же гілці (в той же час у неї є більш ширший функціонал), коли в той же час checkout створює та переходить в нову гілку. У разі, якщо ви помилилися, то ви можете замінити локальні зміни, використовуючи команду git checkout - BRANCH_NAME відбудеться заміна змін в вашому робочому каталозі, на те, що зараз знаходиться в HEAD. Зміни, вже внесені в індекс, також як і нові файли, будуть збережені.</td>
    </tr>
    <tr>
        <td class="commands">git branch</td>
        <td>Команда робить дещо більше, ніж просто створює і видаляє гілки. При запуску без параметрів, ви отримаєте простий список наявних у вас гілок, опції --merged і --no-merged можуть відфільтрувати цей список для виведення тільки тих гілок, які злиті або ще не злиті в поточну гілку.  Щоб подивитися останній Комміт на кожній з гілок, виконайте команду git branch -v. Щоб подивитися ті гілки, які ви вже злили з поточною, можете виконати команду git branch --merged. Для того щоб видалити  гілку необхідно використати команду git branch -d, для того щоб видалити останню гілку, напрацювання якої ще не злиті, та зметою уникнення помилки потрібно використати опцію -D. Щоб побачити всі гілки, що містять напрацювання, які ви поки ще не злили в поточну гілку, виконайте команду git branch --no-merged.</td>
    </tr>
    <tr>
        <td class="commands">git push</td>
        <td>Команда git push використовується для встановлення зв'язку з віддаленим репозиторієм, обчислення локальних змін відсутніх в ньому, і власне їх передачі в вищезгаданий репозиторій. Цій команді потрібно право запису до головного сховища, тому вона використовує аутентифікацію, ця команда спрацьовує тільки в разі, якщо ви клонували з сервера, на якому у вас є права на запис, і якщо ніхто інший з тих пір не виконував команду push. Якщо ви і хтось ще одночасно клонуєте, потім він виконує команду push, а після нього виконати команду push спробуєте ви, то ваш push точно буде відхилений. Вам доведеться спочатку отримати зміни і об'єднати їх з вашими і тільки після цього вам буде дозволено виконати push.
            Коли ви хочете поділитися своїми напрацюваннями, вам необхідно відправити їх в віддалений репозиторій. Команда для цього дії проста: git push remote-name branch-name. Щоб відправити вашу гілку master на сервер origin (повторимося, що клонування зазвичай налаштовує обидва цих імені автоматично), ви можете виконати наступну команду для відправки ваших коммітов: git push origin master.</td>
    </tr>
    <tr>
        <td class="commands">git pull</td>
        <td>Що робить ця команда? Команда pull забирає зміни з віддаленого сховища та інтегрує їх зі змінами в локальному репозиторії. Всередині себе насправді вона виконує дві команди: git fetch та git merge. Команда git fetch зливає всі дані з проекту, які знаходяться в нашому remote репозиторії. Всі дані яких у нас немає вона зливає, але не застосовує в наші гілки. І потім git merge мерджіт поточну гілку з такою ж гілкою зі сховищ. Для коректної роботи команди є два варіанти роботи із нею: перший варіант необхідно вакзувати git pull <remote> <branch>; другий варіант це вказати трекінг інформацію для цієї гілки і тоді ми завжди будемо пуліть правильну гілку
            git branch --set-upstream-to = remote / branch.</td>
    </tr>
    <tr>
        <td class="commands">git merge</td>
        <td>Ця команда використовується для злиття однієї або декількох гілок в поточну. Потім вона встановлює покажчик поточної гілки на результуючий Комміт. практично всі використання мають вигляд git merge branch із зазначенням єдиною гілки для злиття.</td>
    </tr>
    <tr>
        <td class="commands">git clone</td>
        <td>Навіщо потрібна команда git clone? Є два основних способи почати роботу з Git: використавши команду git init (див. статтю "Команда git init"); використавши команду git clone.
            Слово "clone" в команді git clone, звичайно, розшифровується як "клонувати". Сама команда має таку форму запису: git clone <посилання на репозиторій> <назва папки> Тобто ми просимо Git створити копію сховища, який знаходиться за посиланням (<посилання на репозиторій>), і можемо вказати назву нової папки, в яку Git скопіює репозиторій (<назва папки>).</td>
    </tr>
    <tr>
</table>
        <h2>Advanced</h2>
<table>
        <td class="commands">git revert</td>
        <td>Ця команда допомагає безпечно скасувати операцію без втрати історії коммітов. Команда скасовує дії минулих коммітов, створюючи новий, який містить всі скасовані зміни. Ця команда корисна, коли ви вже запущено зміни в віддалений репозиторій, так як вона зберігає недоторканим вихідний комміт.</td>
    </tr>
    <tr>
        <td class="commands">git reset</td>
        <td>Команда git reset - це потужний спосіб скасувати операцію. Існує три можливих аргументу: -mixed Значення за замовчуванням. Команда git reset --mixed аналогічна git reset. Ви переведіть HEAD на останній Комміт, і всі зміни, додані після нього, будуть доступні в якості неотслежіваемих (untracked) змін в вашому робочому каталозі.
            -soft HEAD перемикається на останній Комміт, однак, зміни, додані після цієї фіксації, залишаються з позначкою staged.
            -hard вкористовуйте команду git reset --hard тільки тоді, коли ви знаєте, що робите. Ви переведіть HEAD на останній Комміт і знищите зміни, зроблені після нього. Ця дія не може бути скасовано. Ви не повинні використовувати git reset, коли ви вже запущено дані на віддалений репозиторій. Видалення коммітов іншого члена команди порушить його робочий процес.
            Використовуйте git reset - [ім'я файлу], щоб скасувати зміни в файлі, який ще не був зафіксований.
        </td>
    </tr>
    <tr>
        <td class="commands">git rebase</td>
        <td>Команда git rebase переміщує історію всієї гілки поверх іншої, переписуючи історію проекту новими коммітов. Команда корисна, якщо ви віддаєте перевагу чисту і лінійну історію проекту. Однак перебудувати зміни, перенесені в головну гілку віддаленого сховища небезпечно, т. К. Ви будете змінювати історію головної гілки, в той час як члени вашої команди будуть продовжувати працювати над нею.</td>
    </tr>
    <tr>
        <td class="commands">git cherry-pick</td>
        <td>Команда git cherry-pick використовується для того щоб взяти зміни, внесені будь-яким коммітов, і спробувати застосувати їх заново у вигляді нового коммітов нагорі поточної гілки. Це може виявитися корисним щоб забрати парочку коммітов з іншої гілки без повного злиття з тією гілкою.</td>
    </tr>
    <tr>
        <td class="commands">git stash</td>
        <td>Команда git stash дозволяє на час архівувати (або «відкласти») зміни, зроблені в робочій копії, щоб ви могли застосувати їх пізніше. Відкладання змін корисно, якщо вам необхідно перемкнути контекст і ви поки не готові до створення коммітов.</td>
    </tr>
</table>
<p> <span>.gitignore файл</span> - це файл в якому ми можемо прописати список небажаних файлів, які не повинні потрапити у віддалений репозиторій</p>
</body>
</html>